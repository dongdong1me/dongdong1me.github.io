<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Dongdong Guo">





<title>RunLoop | EvaSite</title>






    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 4.2.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo" ><a style="font-weight: bold;"  href="/">Eva&#39;s Site</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default" type="hidden">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Eva&#39;s Site</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">RunLoop</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Dongdong Guo</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">March 30, 2020&nbsp;&nbsp;22:11:19</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="什么是RunLoop"><a href="#什么是RunLoop" class="headerlink" title="什么是RunLoop"></a>什么是RunLoop</h2><p>RunLoop 是一种高级循环机制，让程序持续运行，当没有事件时，RunLoop 会进入休眠状态，有事件发生时， RunLoop 会去找对应的 Handler 处理事件。RunLoop 可以让线程在需要做事的时候忙起来，不需要的话就让线程休眠。</p>
<h3 id="RunLoop与线程"><a href="#RunLoop与线程" class="headerlink" title="RunLoop与线程"></a>RunLoop与线程</h3><ul>
<li>RunLoop 和线程是绑定到一起的，每条线程都有唯一一个与之对应的RunLoop对象。但是我们在创建线程时，需要手动创建runloop</li>
<li>不能自己创建 RunLoop 对象，但是可以获取系统提供的 RunLoop 对象。</li>
<li>主线程的RunLoop 对象是由系统创建好的。应用程序启动时，在main函数中会启动一个RunLoop，来保持程序运行。但是子线程中的 runloop 对象需要我们手动获取。</li>
</ul>
<p>主线程的 Runloop 会在应用启动的时候完成启动，其他线程的 Runloop 默认并不会启动，需要我们手动启动</p>
<h3 id="RunLoop的结构"><a href="#RunLoop的结构" class="headerlink" title="RunLoop的结构"></a>RunLoop的结构</h3><h4 id="CFRunLoop"><a href="#CFRunLoop" class="headerlink" title="__CFRunLoop"></a>__CFRunLoop</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//RunLoop所对应的线程</span></span><br><span class="line">    pthread_t _pthread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标记为common的mode的集合，mode的name</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">//commonMode的item集合</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前的mode</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储的是CFRunLoopModeRef</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;</span><br><span class="line"> </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个 runloop 对象包含 ：一个 线程(_pthread)  、若干个Mode，若干个commonMode，还有一个当前运行的Mode</p>
<h4 id="CFRunLoopModeRef"><a href="#CFRunLoopModeRef" class="headerlink" title="CFRunLoopModeRef"></a>CFRunLoopModeRef</h4><p>Mode可以视为事件的管家，一个Mode管理着各种事件，它的结构如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//mode的名称</span></span><br><span class="line">    <span class="built_in">CFStringRef</span> _name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sources0事件</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sources1事件</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//observers事件</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//timers事件</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个CFRunLoopMode对象有一个name，若干source0、source1、timer、observer和若干port，可见事件都是由Mode在管理，而RunLoop管理Mode。<br>每次调用Runloop的主函数__CFRunLoopRun()时必须指定一种Mode，这个Mode称为 _currentMode**，当切换Mode时必须退出当前Mode，然后重新进入Runloop以保证不同Mode的Source/Timer/Observer互不影响。</p>
<p>Runloop Mode 实际上是 Source，Timer 和 Observer 的集合，不同的 Mode 把不同组的 Source，Timer 和 Observer 隔绝开来。Runloop 在某个时刻只能跑在一个 Mode 下，处理这一个 Mode 当中的 Source，Timer 和 Observer。</p>
<table>
<thead>
<tr>
<th>CFRunLoopMode</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>NSDefaultRunLoopMode</td>
<td>默认模式是用于大多数操作的模式。大多数时候使用此模式来启动RunLoop并配置输入源</td>
</tr>
<tr>
<td>NSConnectionReplyMode</td>
<td>Cocoa将此模式与NSConnection对象结合使用以监测回应。几乎不需要自己使用此模式</td>
</tr>
<tr>
<td>NSModalPanelRunLoopMode</td>
<td>Cocoa使用此模式来识别用于模式面板的事件</td>
</tr>
<tr>
<td>NSEventTrackingRunLoopMode</td>
<td>Cocoa使用此模式来限制鼠标拖动loop和其他类型的用户界面跟踪loop期间的传入事件。通常用不到。</td>
</tr>
<tr>
<td>NSRunLoopCommonModes</td>
<td>是NSDefaultRunLoopMode和NSEventTrackingRunLoopMode集合，在这种模式下RunLoop分别注册了NSDefaultRunLoopMode和UITrackingRunLoopMode。当然也可以通过调用CFRunLoopAddCommonMode()方法将自定义Mode放到kCFRunLoopCommonModes组合</td>
</tr>
</tbody></table>
<p>在iOS中公开暴露只有NSDefaultRunLoopMode和NSRunLoopCommonModes。</p>
<h4 id="RunLoop-Source"><a href="#RunLoop-Source" class="headerlink" title="RunLoop Source"></a>RunLoop Source</h4><p>Run Loop Source分为Source、Observer、Timer三种，他们统称为ModeItem。</p>
<ul>
<li><p>CFRunLoopSource<br>  CFRunLoopSource分source0和source1两个版本</p>
</li>
<li><p>CFRunLoopObserver<br>  CFRunLoopObserver是观察者，可以观察RunLoop的各种状态，并抛出回调</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) &#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>), <span class="comment">//即将进入run loop</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>), <span class="comment">//即将处理timer</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>),<span class="comment">//即将处理source</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>),<span class="comment">//即将进入休眠</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>),<span class="comment">//被唤醒但是还没开始处理事件</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>),<span class="comment">//run loop已经退出</span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CFRunLoopTimer<br>  CFRunLoopTimer是定时器，可以在设定的时间点抛出回调，CFRunLoopTimer和NSTimer是toll-free bridged的，可以相互转换。</p>
</li>
</ul>
<h3 id="RunLoop实现"><a href="#RunLoop实现" class="headerlink" title="RunLoop实现"></a>RunLoop实现</h3><p>下面从以下3个方面介绍RunLoop的实现。</p>
<p>获取RunLoop<br>添加Mode<br>添加Run Loop Source</p>
<h4 id="获取RunLoop"><a href="#获取RunLoop" class="headerlink" title="获取RunLoop"></a>获取RunLoop</h4><p>从苹果开放的API来看，不允许我们直接创建RunLoop对象，只能通过以下几个函数来获取RunLoop:</p>
<p>CFRunLoopRef CFRunLoopGetCurrent(void)<br>CFRunLoopRef CFRunLoopGetMain(void)<br>+(NSRunLoop *)currentRunLoop<br>+(NSRunLoop *)mainRunLoop</p>
<p>前两个是Core Foundation中的API，后两个是Foundation中的API。</p>
<ul>
<li>CFRunLoopGetCurrent<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取当前所在线程的RunLoop</span></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetCurrent</span>(<span class="keyword">void</span>) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> rl = (<span class="built_in">CFRunLoopRef</span>)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">    <span class="keyword">if</span> (rl) <span class="keyword">return</span> rl;</span><br><span class="line">    <span class="comment">//传入当前线程</span></span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet0(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>在CFRunLoopGetCurrent函数内部调用了_CFRunLoopGet0()，传入的参数是当前线程pthread_self()。这里可以看出，CFRunLoopGetCurrent函数必须要在线程内部调用，才能获取当前线程的RunLoop。也就是说子线程的RunLoop必须要在子线程内部获取</p>
<ul>
<li>CFRunLoopGetMain<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取主线程的RunLoop</span></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetMain</span>(<span class="keyword">void</span>) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">CFRunLoopRef</span> __main = <span class="literal">NULL</span>; <span class="comment">// no retain needed</span></span><br><span class="line">    <span class="comment">//传入主线程</span></span><br><span class="line">    <span class="keyword">if</span> (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); <span class="comment">// no CAS needed</span></span><br><span class="line">    <span class="keyword">return</span> __main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>在CFRunLoopGetMain函数内部也调用了_CFRunLoopGet0()，传入的参数是主线程pthread_main_thread_np()。可以看出，CFRunLoopGetMain()不管在主线程还是子线程中调用，都可以获取到主线程的RunLoop。</p>
<ul>
<li>CFRunLoopGet0</li>
</ul>
<pre><code class="objc"></code></pre>
<p>RunLoop和线程的一一对应的，对应的方式是以key-value的方式保存在一个全局字典中<br>主线程的RunLoop会在初始化全局字典时创建<br>子线程的RunLoop会在第一次获取的时候创建，如果不获取的话就一直不会被创建<br>RunLoop会在线程销毁时销毁</p>
<h4 id="添加Mode"><a href="#添加Mode" class="headerlink" title="添加Mode"></a>添加Mode</h4><p>在Core Foundation中，针对Mode的操作，苹果只开放了以下3个API(Cocoa中也有功能一样的函数，不再列出):<br>CFRunLoopAddCommonMode(CFRunLoopRef rl, CFStringRef mode)<br>CFStringRef CFRunLoopCopyCurrentMode(CFRunLoopRef rl)<br>CFArrayRef CFRunLoopCopyAllModes(CFRunLoopRef rl)</p>
<ul>
<li>CFRunLoopAddCommonMode</li>
</ul>
<h4 id="添加Run-Loop-Source（ModeItem）"><a href="#添加Run-Loop-Source（ModeItem）" class="headerlink" title="添加Run Loop Source（ModeItem）"></a>添加Run Loop Source（ModeItem）</h4><p>我们可以通过以下接口添加/移除各种事件:</p>
<p>void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef mode)<br>void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef mode)<br>void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef mode)<br>void CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef * mode)<br>void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode)<br>void CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode)</p>
<p>区别在于observer和timer只能被添加到一个RunLoop的一个或者多个mode中，比如一个timer被添加到主线程的RunLoop中，则不能再把该timer添加到子线程的RunLoop，而source没有这个限制，不管是哪个RunLoop，只要mode中没有，就可以添加。<br>这个区别在文章最开始的结构体中也可以发现，CFRunLoopSource结构体中有保存RunLoop对象的数组，而CFRunLoopObserver和CFRunLoopTimer只有单个RunLoop对象。</p>
<h3 id="RunLoop运行"><a href="#RunLoop运行" class="headerlink" title="RunLoop运行"></a>RunLoop运行</h3><p>在Core Foundation中我们可以通过以下2个API来让RunLoop运行：</p>
<p>void CFRunLoopRun(void)</p>
<p>在默认的mode下运行当前线程的RunLoop。</p>
<p>CFRunLoopRunResult CFRunLoopRunInMode(CFStringRef mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</p>
<p>在指定mode下运行当前线程的RunLoop。</p>
<p><strong><em>小结</em></strong><br>RunLoop实际很简单，它是一个对象，它和线程是一一对应的，每个线程都有一个对应的RunLoop对象，主线程的RunLoop会在程序启动时自动创建，子线程需要手动获取来创建。<br>RunLoop运行的核心是一个do..while..循环，遍历所有需要处理的事件，如果有事件处理就让线程工作，没有事件处理则让线程休眠，同时等待事件到来。</p>
<h2 id="RunLoop应用"><a href="#RunLoop应用" class="headerlink" title="RunLoop应用"></a>RunLoop应用</h2><h3 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h3><p>前面一直提到Timer Source作为事件源，事实上它的上层对应就是NSTimer（其实就是CFRunloopTimerRef）这个开发者经常用到的定时器（底层基于使用mk_timer实现）.NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。</p>
<h3 id="GCD-Timer"><a href="#GCD-Timer" class="headerlink" title="GCD Timer"></a>GCD Timer</h3><p>GCD 则不同，GCD 的线程管理是通过系统来直接管理的。GCD Timer 是通过 dispatch port 给 RunLoop 发送消息，来使 RunLoop 执行相应的 block，如果所在线程没有 RunLoop，那么 GCD 会临时创建一个线程去执行 block，执行完之后再销毁掉，因此 GCD 的 Timer 是不依赖 RunLoop 的。</p>
<h3 id="CADisplayLink"><a href="#CADisplayLink" class="headerlink" title="CADisplayLink"></a>CADisplayLink</h3><p>CADisplayLink是一个执行频率（fps）和屏幕刷新相同（可以修改preferredFramesPerSecond改变刷新频率）的定时器，它也需要加入到RunLoop才能执行。与NSTimer类似，CADisplayLink同样是基于CFRunloopTimerRef实现，底层使用mk_timer（可以比较加入到RunLoop前后RunLoop中timer的变化）</p>
<h3 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h3><p>在iOS应用启动后会注册两个Observer管理和维护AutoreleasePool:监听</p>
<p>kCFRunLoopEntry; // 进入runloop之前，创建一个自动释放池<br>kCFRunLoopBeforeWaiting; // 休眠之前，销毁自动释放池，创建一个新的自动释放池<br>kCFRunLoopExit; // 退出runloop之前，销毁自动释放池</p>
<h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。<br>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。<br>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>
<h3 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h3><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。<br>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。<br>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
<h3 id="UI更新"><a href="#UI更新" class="headerlink" title="UI更新"></a>UI更新</h3><h3 id="NSURLConnection"><a href="#NSURLConnection" class="headerlink" title="NSURLConnection"></a>NSURLConnection</h3><h3 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>
<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
<h3 id="更多RunLoop的实践"><a href="#更多RunLoop的实践" class="headerlink" title="更多RunLoop的实践"></a>更多RunLoop的实践</h3><h4 id="滚动Scrollview导致定时器失效"><a href="#滚动Scrollview导致定时器失效" class="headerlink" title="滚动Scrollview导致定时器失效"></a>滚动Scrollview导致定时器失效</h4><p>因为当你滚动Scrollview的时候，RunLoop会切换到UITrackingRunLoopMode 模式，而定时器运行在defaultMode下面，系统一次只能处理一种模式的RunLoop，所以导致defaultMode下的定时器失效。<br>解决方法：</p>
<ol>
<li><p>把timer注册到NSRunLoopCommonModes，它包含了defaultMode和trackingMode两种模式。</p>
</li>
<li><p>使用GCD创建定时器，GCD创建的定时器不会受RunLoop的影响</p>
</li>
</ol>
<h4 id="图片下载"><a href="#图片下载" class="headerlink" title="图片下载"></a>图片下载</h4><p>由于图片渲染到屏幕需要消耗较多资源，为了提高用户体验，当用户滚动Tableview的时候，只在后台下载图片，但是不显示图片，当用户停下来的时候才显示图片。</p>
<p>[self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@”imgName”] afterDelay:3.0 inModes:@[NSDefaultRunLoopMode]];</p>
<p>上面的代码可以达到如下效果：<br>用户点击屏幕，在主线程中，三秒之后显示图片，但是当用户点击屏幕之后，如果此时用户又开始滚动textview，那么就算过了三秒，图片也不会显示出来，当用户停止了滚动，才会显示图片。<br>这是因为限定了方法setImage只能在NSDefaultRunLoopMode 模式下使用。而滚动textview的时候，程序运行在tracking模式下面，所以方法setImage不会执行</p>
<h4 id="常驻线程"><a href="#常驻线程" class="headerlink" title="常驻线程"></a>常驻线程</h4><p>需要创建一个在后台一直存在的程序，来做一些需要频繁处理的任务。比如检测网络状态等。<br>默认情况一个线程创建出来，运行完要做的事情，线程就会消亡。而程序启动的时候，就创建的主线程已经加入到RunLoop，所以主线程不会消亡。</p>
<h4 id="观察事件状态，优化性能"><a href="#观察事件状态，优化性能" class="headerlink" title="观察事件状态，优化性能"></a>观察事件状态，优化性能</h4>
        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Dongdong Guo</span>
                    </p>
                
                
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/04/01/面试题集/">题集</a>
            
            
            <a class="next" rel="next" href="/2020/03/27/内存管理/">内存管理</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Dongdong Guo | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
